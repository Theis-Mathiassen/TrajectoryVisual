from Trajectory import Trajectory
from Node import Node, NodeDiff
import numpy as np
import math
from src.Filter import Filter

class TurningPoint(Filter):
    degrees: float

    def __init__(self, params):
        self.degrees = params["degrees"]

    def filterTrajectories(self, trajectories: list[Trajectory], switch: bool=False):
        # Default behaviour is to look for nodes that introduce a turn in the trajectory,
        # which is greater than the threshold in degrees.
        # This behaviour can be switched to the opposite by enabling the switch flag.
        # In this case the filter looks for nodes that introduce a turn,
        # which is under the threshold in degrees.
        # (If you want to input radians, find that value on caller side.)

        # Output list      
        out = []

        # Loop through all trajectories
        for traj in trajectories:

            # Define a list to gather all nodes that are not filtered out.
            intermediateOut = []

            # Run the filter on the trajectory
            filteredNodes = findTurningPoints(traj, self.degrees, switch)
            
            # Assemble a list of nodes that pass the filter
            for index in range(len(traj.nodes)):
                if index not in [node.id for node in filteredNodes]:
                    intermediateOut.append(traj.nodes[index])

            # Add this list to the final output list
            out.append(intermediateOut)
        
        # Return the filtered trajectories
        return out
        
def findTurningPoints(traj: Trajectory, degrees: float, thresholdSwitch: bool=False):
    # Threshold input parameter is assumed to be some number of degrees.
    # Threshold is additionally assumed to be between 0 and 180. 
    # (Clockwise vs. Counterclockwise is irrelevant therefore no negative value.)
    
    # Declare output array
    out = []

    # Loop through the trajectory nodes except end nodes
    for i in range(1, len(traj.nodes) - 1):
        # Find the nodes before and after the one in question
        before = traj.nodes[i-1]
        after = traj.nodes[i+1]

        # Define vectors with coordinates equal to the vector difference in the point vectors
        firstDiffVector = np.array(NodeDiff(before, traj.nodes[i]))
        secondDiffVector = np.array(NodeDiff(traj.nodes[i], after))

        # Compute arc-tan values of vectors measured in radians
        firstAngle = math.atan2(firstDiffVector[1], firstDiffVector[0])
        secondAngle = math.atan2(secondDiffVector[1], secondDiffVector[0])

        # Initial machine epsilon checks
        if abs(firstAngle) <= np.finfo(float).eps:
            firstAngle = 0
        if abs(secondAngle) <= np.finfo(float).eps:
            secondAngle = 0

        # Compute angle, in degrees, between the two linesegments generated by the two pairs of points
        # (This is where the conversion between degrees and radians is done.)
        finalAngle = ((abs(abs(secondAngle)-abs(firstAngle))/(math.pi))*180)
        
        # Final machine epsilon check
        if abs(finalAngle) <= np.finfo(float).eps:
            continue

        # Check if the angle is above the threshold when switch is off
        if abs(finalAngle) >= degrees and thresholdSwitch == False:
            out.append(traj.nodes[i])
        # Check if the angle is below the threshold when switch is on
        elif abs(finalAngle) <= degrees and thresholdSwitch == True:
            out.append(traj.nodes[i])

    # After all nodes in the trajectory are processed, 
    # return the nodes from the trajectory
    # that create an angle that is greater than the threshold.
    return out

if __name__=="__main__":
    # Define nodes that create a 90-degree angle
    point1 = Node(0, -1.0, 0.0, 0.0)
    point2 = Node(1, 0.0, 0.0, 1.0)
    point3 = Node(2, 0.0, 1.0, 2.0)

    # Combine them into a trajectory
    traj = Trajectory(0, [point1, point2, point3])

    # Create a filter object initialized with the degree to look for. 
    # (Try 91, 90 and 89 for testing purposes and look at the output.) 
    filterTurn = TurningPoint({"degrees": 91.0})

    # We expect the middle node to be identified as a turning point when the switch is off, so the returned ID should be 1.
    for node in findTurningPoints(traj, 89):
        print(node.id)

    # Similar case, but where the switch is on and 'direction' of comparison is reversed.
    for node in findTurningPoints(traj, 91, True):
        print(node.id)

    # Run the filter with default settings
    print(filterTurn.filterTrajectories([traj]))

    # Run the filter with the switch turned on
    print(filterTurn.filterTrajectories([traj], True))
